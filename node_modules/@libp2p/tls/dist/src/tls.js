/**
 * @packageDocumentation
 *
 * Implements the spec at https://github.com/libp2p/specs/blob/master/tls/tls.md
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { tls } from '@libp2p/tls'
 *
 * const node = await createLibp2p({
 *   // ...other options
 *   connectionEncrypters: [
 *     tls()
 *   ]
 * })
 * ```
 */
import { TLSSocket, connect } from 'node:tls';
import { serviceCapabilities } from '@libp2p/interface';
import { HandshakeTimeoutError } from './errors.js';
import { generateCertificate, verifyPeerCertificate, itToStream, streamToIt } from './utils.js';
import { PROTOCOL } from './index.js';
export class TLS {
    protocol = PROTOCOL;
    log;
    privateKey;
    constructor(components) {
        this.log = components.logger.forComponent('libp2p:tls');
        this.privateKey = components.privateKey;
    }
    [Symbol.toStringTag] = '@libp2p/tls';
    [serviceCapabilities] = [
        '@libp2p/connection-encryption'
    ];
    async secureInbound(conn, options) {
        return this._encrypt(conn, true, options);
    }
    async secureOutbound(conn, options) {
        return this._encrypt(conn, false, options);
    }
    /**
     * Encrypt connection
     */
    async _encrypt(conn, isServer, options) {
        const opts = {
            ...await generateCertificate(this.privateKey),
            isServer,
            // require TLS 1.3 or later
            minVersion: 'TLSv1.3',
            maxVersion: 'TLSv1.3',
            // accept self-signed certificates
            rejectUnauthorized: false
        };
        let socket;
        if (isServer) {
            socket = new TLSSocket(itToStream(conn), {
                ...opts,
                // require clients to send certificates
                requestCert: true
            });
        }
        else {
            socket = connect({
                socket: itToStream(conn),
                ...opts
            });
        }
        return new Promise((resolve, reject) => {
            options?.signal?.addEventListener('abort', () => {
                const err = new HandshakeTimeoutError();
                socket.destroy(err);
                reject(err);
            });
            const verifyRemote = () => {
                const remote = socket.getPeerCertificate();
                verifyPeerCertificate(remote.raw, options?.remotePeer, this.log)
                    .then(remotePeer => {
                    this.log('remote certificate ok, remote peer %p', remotePeer);
                    resolve({
                        remotePeer,
                        conn: {
                            ...conn,
                            ...streamToIt(socket)
                        }
                    });
                })
                    .catch((err) => {
                    reject(err);
                });
            };
            socket.on('error', (err) => {
                reject(err);
            });
            socket.once('secure', () => {
                this.log('verifying remote certificate');
                verifyRemote();
            });
        })
            .catch(err => {
            socket.destroy(err);
            throw err;
        });
    }
}
//# sourceMappingURL=tls.js.map