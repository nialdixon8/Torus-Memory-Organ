import { publicKeyToProtobuf } from '@libp2p/crypto/keys';
import { logger } from '@libp2p/logger';
import {} from 'interface-datastore/key';
import NanoDate from 'timestamp-nano';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { SignatureCreationError } from './errors.js';
import { IpnsEntry } from './pb/ipns.js';
import { createCborData, ipnsRecordDataForV1Sig, ipnsRecordDataForV2Sig, normalizeValue } from './utils.js';
const log = logger('ipns');
const DEFAULT_TTL_NS = 60 * 60 * 1e+9; // 1 Hour or 3600 Seconds
export const namespace = '/ipns/';
export const namespaceLength = namespace.length;
const defaultCreateOptions = {
    v1Compatible: true,
    ttlNs: DEFAULT_TTL_NS
};
export async function createIPNSRecord(privateKey, value, seq, lifetime, options = defaultCreateOptions) {
    // Validity in ISOString with nanoseconds precision and validity type EOL
    const expirationDate = new NanoDate(Date.now() + Number(lifetime));
    const validityType = IpnsEntry.ValidityType.EOL;
    const ttlNs = BigInt(options.ttlNs ?? DEFAULT_TTL_NS);
    return _create(privateKey, value, seq, validityType, expirationDate.toString(), ttlNs, options);
}
export async function createIPNSRecordWithExpiration(privateKey, value, seq, expiration, options = defaultCreateOptions) {
    const expirationDate = NanoDate.fromString(expiration);
    const validityType = IpnsEntry.ValidityType.EOL;
    const ttlNs = BigInt(options.ttlNs ?? DEFAULT_TTL_NS);
    return _create(privateKey, value, seq, validityType, expirationDate.toString(), ttlNs, options);
}
const _create = async (privateKey, value, seq, validityType, validity, ttl, options = defaultCreateOptions) => {
    seq = BigInt(seq);
    const isoValidity = uint8ArrayFromString(validity);
    const normalizedValue = normalizeValue(value);
    const encodedValue = uint8ArrayFromString(normalizedValue);
    const data = createCborData(encodedValue, validityType, isoValidity, seq, ttl);
    const sigData = ipnsRecordDataForV2Sig(data);
    const signatureV2 = await privateKey.sign(sigData);
    let pubKey;
    // if we cannot derive the public key from the PeerId (e.g. RSA PeerIDs),
    // we have to embed it in the IPNS record
    if (privateKey.type === 'RSA') {
        pubKey = publicKeyToProtobuf(privateKey.publicKey);
    }
    if (options.v1Compatible === true) {
        const signatureV1 = await signLegacyV1(privateKey, encodedValue, validityType, isoValidity);
        const record = {
            value: normalizedValue,
            signatureV1,
            validity,
            validityType,
            sequence: seq,
            ttl,
            signatureV2,
            data
        };
        if (pubKey != null) {
            record.pubKey = pubKey;
        }
        return record;
    }
    else {
        const record = {
            value: normalizedValue,
            validity,
            validityType,
            sequence: seq,
            ttl,
            signatureV2,
            data
        };
        if (pubKey != null) {
            record.pubKey = pubKey;
        }
        return record;
    }
};
export { unmarshalIPNSRecord } from './utils.js';
export { marshalIPNSRecord } from './utils.js';
export { multihashToIPNSRoutingKey } from './utils.js';
export { multihashFromIPNSRoutingKey } from './utils.js';
export { extractPublicKeyFromIPNSRecord } from './utils.js';
/**
 * Sign ipns record data using the legacy V1 signature scheme
 */
const signLegacyV1 = async (privateKey, value, validityType, validity) => {
    try {
        const dataForSignature = ipnsRecordDataForV1Sig(value, validityType, validity);
        return await privateKey.sign(dataForSignature);
    }
    catch (error) {
        log.error('record signature creation failed', error);
        throw new SignatureCreationError('Record signature creation failed');
    }
};
//# sourceMappingURL=index.js.map